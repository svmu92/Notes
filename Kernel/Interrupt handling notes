
Interrupts
------------
- Interrupts enable hardware to signal to the processor.

- An interrupt is physically produced by electronic signals originating from hardware
devices and directed into input pins on an interrupt controller, a simple chip that multi-
plexes multiple interrupt lines into a single line to the processor. Upon receiving an inter-
rupt, the interrupt controller sends a signal to the processor.The processor detects this sig-
nal and interrupts its current execution to handle the interrupt.The processor can then
notify the operating system that an interrupt has occurred, and the operating system can
handle the interrupt appropriately.

- Different devices can be associated with different interrupts by means of a unique
value associated with each interrupt. In turn,
the operating system can service each interrupt with its corresponding handler.

- Interrupts associated with devices on the PCI bus, for example, generally
are dynamically assigned.


- The function the kernel runs in response to a specific interrupt is called an interrupt handler
or interrupt service routine (ISR).
- They run in a special context called interrupt context.This special context is
occasionally called atomic context because, code executing in this context is
unable to block.

- The processing of interrupts is split into two parts, or halves.The interrupt handler is the top half.
The top half is run immediately upon receipt of the interrupt and performs only the
work that is time-critical, such as acknowledging receipt of the interrupt or resetting the
hardware.Work that can be performed later is deferred until the bottom half.The bottom
half runs in the future, at a more convenient time, with all interrupts enabled.


Registering an Interrupt handler
--------------------------------

Drivers can register an interrupt handler and enable a given interrupt line for handling
with the function request_irq() , which is declared in <linux/interrupt.h> :
"""
/* request_irq: allocate a given interrupt line */
int request_irq(unsigned int irq,
irq_handler_t handler,
unsigned long flags,
const char *name,
void *dev)
"""

- The first parameter, 'irq' , specifies the interrupt number to allocate.
- The second parameter, handler , is a function pointer to the actual interrupt handler
that services this interrupt.This function is invoked whenever the operating system
receives the interrupt.
"""
typedef irqreturn_t (*irq_handler_t)(int, void *);
"""

- The third parameter, 'flags' , can be either zero or a bit mask of one or more of the flags
defined in <linux/interrupt.h> .

"""
#define IRQF_SHARED             0x00000080
#define IRQF_PROBE_SHARED       0x00000100
#define __IRQF_TIMER            0x00000200
#define IRQF_PERCPU             0x00000400
#define IRQF_NOBALANCING        0x00000800
#define IRQF_IRQPOLL            0x00001000
#define IRQF_ONESHOT            0x00002000
#define IRQF_NO_SUSPEND         0x00004000
#define IRQF_FORCE_RESUME       0x00008000
#define IRQF_NO_THREAD          0x00010000
#define IRQF_EARLY_RESUME       0x00020000
#define IRQF_COND_SUSPEND       0x00040000
#define IRQF_NO_AUTOEN          0x00080000
#define IRQF_NO_DEBUG           0x00100000
"""

IRQF_DISABLED (deprecated) —When
set, this flag instructs the kernel to disable all interrupts
when executing this interrupt handler.When unset, interrupt handlers run with all
interrupts except their own enabled.

IRQF_SAMPLE_RANDOM (deprecated) —This flag specifies that interrupts generated by this device
should contribute to the kernel entropy pool.The kernel entropy pool provides
truly random numbers derived from various random events. If this flag is specified,
the timing of interrupts from this device are fed to the pool as entropy.

IRQF_TIMER —This flag specifies that this handler processes interrupts for the sys-
tem timer.
"interrupt.h                73 #define __IRQF_TIMER  0x00000200"

IRQF_SHARED —This flag specifies that the interrupt line can be shared among mul-
tiple interrupt handlers. Each handler registered on a given line must specify this
flag; otherwise, only one handler can exist per line.



- The fourth parameter, 'name' , is an ASCII text representation of the device associated
with the interrupt. These text names are used by /proc/irq and /proc/interrupts for communica-
tion with the user.


- The fifth parameter, 'dev' , is used for shared interrupt lines.When an interrupt handler
is freed, dev provides a unique cookie to enable the removal of only the
desired interrupt handler from the interrupt line.Without this parameter, it would be
impossible for the kernel to know which handler to remove on a given interrupt line.You
can pass NULL here if the line is not shared, but you must pass a unique cookie if your
interrupt line is shared. This pointer is also passed into the inter-
rupt handler on each invocation.A common practice is to pass the driver’s device struc-
ture:This pointer is unique and might be useful to have within the handlers.

- On success, request_irq() returns zero.A nonzero value indicates an error, in which
case the specified interrupt handler was not registered.A common error is -EBUSY , which
denotes that the given interrupt line is already in use

- Note that request_irq() can sleep and therefore cannot be called from interrupt
context or other situations where code cannot block.

- On registration, an entry corresponding to the interrupt is
created in /proc/irq .The function proc_mkdir() creates new procfs entries.This func-
tion calls proc_create() to set up the new procfs entries, which in turn calls kmalloc()
to allocate memory.


Example:
"""
if (request_irq(irqn, my_interrupt, IRQF_SHARED, "my_device", my_dev)) {
    printk(KERN_ERR "my_device: cannot register IRQ %d\n", irqn);
    return -EIO;
}
"""

- It is important to initialize hardware and register an interrupt
handler in the proper order to prevent the interrupt handler from running before the
device is fully initialized.


Freeing an interrupt handler
----------------------------

- When your driver unloads, you need to unregister your interrupt handler and potentially
disable the interrupt line.To do this, call
"""
void free_irq(unsigned int irq, void *dev);
"""

- If the specified interrupt line is not shared, this function removes the handler and dis-
ables the line. If the interrupt line is shared, the handler identified via dev is removed, but
the interrupt line is disabled only when the last handler is removed.

- A call to free_irq() must be made from process context.


Writing an Interrupt handler
----------------------------

- The following is a declaration of an interrupt handler:
"""
static irqreturn_t intr_handler(int irq, void *dev)
"""

- Since "dev" is passed, the same interrupt handler can be used by multiple devices
because it is unique for each device.

- An interrupt
handler can return two special values, IRQ_NONE or IRQ_HANDLED .The former is returned
when the interrupt handler detects an interrupt for which its device was not the origina-
tor.The latter is returned if the interrupt handler was correctly invoked, and its device did
indeed cause the interrupt.

- Interrupt handlers in Linux need not be reentrant. When a given interrupt handler is execut-
ing, the corresponding interrupt line is masked out on all processors, preventing another
interrupt on the same line from being received. Consequently, the
same interrupt handler is never invoked concurrently to service a nested interrupt.

- When the kernel receives an interrupt, it invokes sequentially each registered handler
on the line. The handler must quickly exit if its associated
device did not generate the interrupt.This requires the hardware device to have a status
register (or similar mechanism) that the handler can check.


Interrupt Context
-------------------
